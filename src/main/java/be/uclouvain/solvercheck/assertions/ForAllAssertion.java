package be.uclouvain.solvercheck.assertions;

import org.quicktheories.QuickTheory;
import org.quicktheories.api.Function3;
import org.quicktheories.api.Function4;
import org.quicktheories.api.Predicate3;
import org.quicktheories.api.Predicate4;
import org.quicktheories.core.Gen;
import org.quicktheories.core.Strategy;

import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * This class implements an "higher order" assertion which checks that the
 * parametric assertion holds for all values generated by the given generator.
 */
public final class ForAllAssertion {
    /** An utility class has no public constructor. */
    private ForAllAssertion() { }

    /**
     * Creates a 1-parametric assertion using the default configuration.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param genA the generator creating the generated 1-parameter
     * @param <A> the type of the parameter produced by the generator
     * @return a hook to conveniently express a 1-parametric assertion.
     */
    public static <A> Forall1<A> forAll(final Gen<A> genA) {
        return forAll(new TestConfiguration(), genA);
    }

    /**
     * Creates a 1-parametric assertion using the given configuration.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param config the configuration of the random args generation.
     * @param genA the generator creating the generated 1-parameter
     * @param <A> the type of the parameter produced by the generator
     * @return a hook to conveniently express a 1-parametric assertion.
     */
    public static <A> Forall1<A> forAll(
            final Supplier<Strategy> config,
            final Gen<A> genA) {

        return new Forall1<>(config, genA);
    }

    /**
     * Creates a 2-parametric assertion using the current configuration.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param genA the generator creating the generated 1st argument.
     * @param genB the generator creating the generated 2nd argument.
     * @param <A> the type of the parameter produced by the 1st generator
     * @param <B> the type of the parameter produced by the 2nd generator
     * @return a hook to conveniently express a 2-parametric assertion.
     */
    public static <A, B> Forall2<A, B> forAll(
            final Gen<A> genA,
            final Gen<B> genB) {

        return forAll(new TestConfiguration(), genA, genB);
    }
    /**
     * Creates a 2-parametric assertion using the given configuration.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param config the configuration of the random args generation.
     * @param genA the generator creating the generated 1st argument.
     * @param genB the generator creating the generated 2nd argument.
     * @param <A> the type of the parameter produced by the 1st generator
     * @param <B> the type of the parameter produced by the 2nd generator
     * @return a hook to conveniently express a 2-parametric assertion.
     */
    public static <A, B> Forall2<A, B> forAll(
            final Supplier<Strategy> config,
            final Gen<A> genA,
            final Gen<B> genB) {

        return new Forall2<>(config, genA, genB);
    }
    /**
     * Creates a 3-parametric assertion using the current configuration.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param genA the generator creating the generated 1st argument.
     * @param genB the generator creating the generated 2nd argument.
     * @param genC the generator creating the generated 3rd argument.
     * @param <A> the type of the parameter produced by the 1st generator
     * @param <B> the type of the parameter produced by the 2nd generator
     * @param <C> the type of the parameter produced by the 3rd generator
     * @return a hook to conveniently express a 3-parametric assertion.
     */
    public static <A, B, C> Forall3<A, B, C> forAll(
            final Gen<A> genA,
            final Gen<B> genB,
            final Gen<C> genC) {

        return forAll(new TestConfiguration(), genA, genB, genC);
    }
    /**
     * Creates a 3-parametric assertion using the given configuration.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param config the configuration of the random args generation.
     * @param genA the generator creating the generated 1st argument.
     * @param genB the generator creating the generated 2nd argument.
     * @param genC the generator creating the generated 3rd argument.
     * @param <A> the type of the parameter produced by the 1st generator
     * @param <B> the type of the parameter produced by the 2nd generator
     * @param <C> the type of the parameter produced by the 3rd generator
     * @return a hook to conveniently express a 3-parametric assertion.
     */
    public static <A, B, C> Forall3<A, B, C> forAll(
            final Supplier<Strategy> config,
            final Gen<A> genA,
            final Gen<B> genB,
            final Gen<C> genC) {

        return new Forall3<>(config, genA, genB, genC);
    }

    /**
     * Creates a 4-parametric assertion using the current configuration.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param genA the generator creating the generated 1st argument.
     * @param genB the generator creating the generated 2nd argument.
     * @param genC the generator creating the generated 3rd argument.
     * @param genD the generator creating the generated 4th argument.
     *
     * @param <A> the type of the parameter produced by the 1st generator
     * @param <B> the type of the parameter produced by the 2nd generator
     * @param <C> the type of the parameter produced by the 3rd generator
     * @param <D> the type of the parameter produced by the 4th generator
     * @return a hook to conveniently express a 4-parametric assertion.
     */
    public static <A, B, C, D> Forall4<A, B, C, D> forAll(
            final Gen<A> genA,
            final Gen<B> genB,
            final Gen<C> genC,
            final Gen<D> genD) {

        return forAll(new TestConfiguration(), genA, genB, genC, genD);
    }
    /**
     * Creates a 4-parametric assertion using the current configuration.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param config the configuration of the random args generation.
     * @param genA the generator creating the generated 1st argument.
     * @param genB the generator creating the generated 2nd argument.
     * @param genC the generator creating the generated 3rd argument.
     * @param genD the generator creating the generated 4th argument.
     *
     * @param <A> the type of the parameter produced by the 1st generator
     * @param <B> the type of the parameter produced by the 2nd generator
     * @param <C> the type of the parameter produced by the 3rd generator
     * @param <D> the type of the parameter produced by the 4th generator
     * @return a hook to conveniently express a 4-parametric assertion.
     */
    public static <A, B, C, D> Forall4<A, B, C, D> forAll(
            final Supplier<Strategy> config,
            final Gen<A> genA,
            final Gen<B> genB,
            final Gen<C> genC,
            final Gen<D> genD) {

        return new Forall4<>(config, genA, genB, genC, genD);
    }

    /**
     * This class provides a hook to create and customize 1-parametric
     * assertions. The set of classes Forall{1..4} pretty much reflects
     * `QuickTheories` set of `TheoryBuilder{1..4}` classes.
     *
     * @param <A> the type of the generated parameter
     */
    public static final class Forall1<A> {
        /** The configuration used when generating the random args. */
        private final Supplier<Strategy> config;
        /** The generator creating the generated 1st argument. */
        private final Gen<A> genA;
        /**
         * A predicate encapsulating the assumptions used to filter out
         * parameter values which are not relevant for the test at hand.
         */
        private Predicate<A> assumptions;

        /**
         * Creates a new hook to facilitate the writing of 1-parametric
         * assertions.
         *
         * @param config the configuration of the random args generation.
         * @param genA the generator creating the generated 1st argument.
         */
        public Forall1(final Supplier<Strategy> config, final Gen<A> genA) {
            this.config = config;
            this.genA = genA;
            this.assumptions = a -> true;
        }

        /**
         * Constrains the values allowed for the generated parameters.
         *
         * @param assumption a predicate that must be true of all values
         * @return this
         */
        public Forall1<A> assuming(final Predicate<A> assumption) {
            this.assumptions = this.assumptions.and(assumption);
            return this;
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameter.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsTrueThat(final Function<A, Assertion> assertion) {
            return () -> {
                QuickTheory.qt(config)
                        .forAll(genA)
                        .assuming(assumptions)
                        .checkAssert(a -> assertion.apply(a).check());
            };
        }
    }

    /**
     * This class provides a hook to create and customize 2-parametric
     * assertions. The set of classes Forall{1..4} pretty much reflects
     * `QuickTheories` set of `TheoryBuilder{1..4}` classes.
     *
     * @param <A> the type of the 1st generated parameter
     * @param <B> the type of the 2nd generated parameter
     */
    public static final class Forall2<A, B> {
        /** the configuration used when generating the random args. */
        private final Supplier<Strategy> config;
        /** The generator creating the generated 1st argument. */
        private final Gen<A> genA;
        /** The generator creating the generated 2nd argument. */
        private final Gen<B> genB;
        /**
         * A predicate encapsulating the assumptions used to filter out
         * parameter values which are not relevant for the test at hand.
         */
        private BiPredicate<A, B> assumptions;

        /**
         * Creates a new hook to facilitate the writing of 2-parametric
         * assertions.
         *
         * @param config the configuration of the random args generation.
         * @param genA the generator creating the generated 1st argument.
         * @param genB the generator creating the generated 2nd argument.
         */
        public Forall2(
                final Supplier<Strategy> config,
                final Gen<A> genA,
                final Gen<B> genB) {

            this.config = config;
            this.genA = genA;
            this.genB = genB;

            this.assumptions = (a, b) -> true;
        }

        /**
         * Constrains the values allowed for the generated parameters.
         *
         * @param assumption a predicate that must be true of all values
         * @return this
         */
        public Forall2<A, B> assuming(final BiPredicate<A, B> assumption) {
            this.assumptions = this.assumptions.and(assumption);
            return this;
        }
        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameters.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsTrueThat(final BiFunction<A, B, Assertion> assertion) {
            return () -> {
                QuickTheory.qt(config)
                        .forAll(genA, genB)
                        .assuming(assumptions)
                        .checkAssert(
                                (a, b) -> assertion.apply(a, b).check()
                        );
            };
        }
    }

    /**
     * This class provides a hook to create and customize 3-parametric
     * assertions. The set of classes Forall{1..4} pretty much reflects
     * `QuickTheories` set of `TheoryBuilder{1..4}` classes.
     *
     * @param <A> the type of the 1st generated parameter
     * @param <B> the type of the 2nd generated parameter
     * @param <C> the type of the 3rd generated parameter
     */
    public static final class Forall3<A, B, C> {
        /** the configuration used when generating the random args. */
        private final Supplier<Strategy> config;
        /** The generator creating the generated 1st argument. */
        private final Gen<A> genA;
        /** The generator creating the generated 2nd argument. */
        private final Gen<B> genB;
        /** The generator creating the generated 3rd argument. */
        private final Gen<C> genC;
        /**
         * A predicate encapsulating the assumptions used to filter out
         * parameter values which are not relevant for the test at hand.
         */
        private Predicate3<A, B, C> assumptions;

        /**
         * Creates a new hook to facilitate the writing of 3-parametric
         * assertions.
         *
         * @param config the configuration of the random args generation.
         * @param genA the generator creating the generated 1st argument.
         * @param genB the generator creating the generated 2nd argument.
         * @param genC the generator creating the generated 3rd argument.
         */
        public Forall3(
                final Supplier<Strategy> config,
                final Gen<A> genA,
                final Gen<B> genB,
                final Gen<C> genC) {

            this.config = config;
            this.genA = genA;
            this.genB = genB;
            this.genC = genC;

            this.assumptions = (a, b, c) -> true;
        }

        /**
         * Constrains the values allowed for the generated parameters.
         *
         * @param assumption a predicate that must be true of all values
         * @return this
         */
        public Forall3<A, B, C> assuming(final Predicate3<A, B, C> assumption) {
            this.assumptions = this.assumptions.and(assumption);
            return this;
        }
        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameters.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsTrueThat(final Function3<A, B, C, Assertion> assertion) {
            return () -> {
                QuickTheory.qt(config)
                        .forAll(genA, genB, genC)
                        .assuming(assumptions)
                        .checkAssert(
                                (a, b, c) -> assertion.apply(a, b, c).check()
                        );
            };
        }
    }

    /**
     * This class provides a hook to create and customize 3-parametric
     * assertions. The set of classes Forall{1..4} pretty much reflects
     * `QuickTheories` set of `TheoryBuilder{1..4}` classes.
     *
     * @param <A> the type of the 1st generated parameter
     * @param <B> the type of the 2nd generated parameter
     * @param <C> the type of the 3rd generated parameter
     * @param <D> the type of the 4th generated parameter
     */
    public static final class Forall4<A, B, C, D> {
        /** the configuration used when generating the random args. */
        private final Supplier<Strategy> config;

        /** The generator creating the generated 1st argument. */
        private final Gen<A> genA;
        /** The generator creating the generated 2nd argument. */
        private final Gen<B> genB;
        /** The generator creating the generated 3rd argument. */
        private final Gen<C> genC;
        /** The generator creating the generated 4th argument. */
        private final Gen<D> genD;
        /**
         * A predicate encapsulating the assumptions used to filter out
         * parameter values which are not relevant for the test at hand.
         */
        private Predicate4<A, B, C, D> assumptions;

        /**
         * Creates a new hook to facilitate the writing of 4-parametric
         * assertions.
         *
         * @param config the configuration of the random args generation.
         * @param genA the generator creating the generated 1st argument.
         * @param genB the generator creating the generated 2nd argument.
         * @param genC the generator creating the generated 3rd argument.
         * @param genD the generator creating the generated 4th argument.
         */
        public Forall4(
                final Supplier<Strategy> config,
                final Gen<A> genA,
                final Gen<B> genB,
                final Gen<C> genC,
                final Gen<D> genD) {

            this.config = config;
            this.genA = genA;
            this.genB = genB;
            this.genC = genC;
            this.genD = genD;

            this.assumptions = (a, b, c, d) -> true;
        }

        /**
         * Constrains the values allowed for the generated parameters.
         *
         * @param assumption a predicate that must be true of all values
         * @return this
         */
        public Forall4<A, B, C, D> assuming(final Predicate4<A, B, C, D> assumption) {
            this.assumptions = this.assumptions.and(assumption);
            return this;
        }
        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameters.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsTrueThat(final Function4<A, B, C, D, Assertion> assertion) {
            return () -> {
                QuickTheory.qt(config)
                        .forAll(genA, genB, genC, genD)
                        .assuming(assumptions)
                        .checkAssert(
                                (a, b, c, d) -> assertion.apply(a, b, c, d).check()
                        );
            };
        }
    }
}
