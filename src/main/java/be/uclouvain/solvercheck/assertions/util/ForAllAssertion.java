package be.uclouvain.solvercheck.assertions.util;

import be.uclouvain.solvercheck.assertions.Assertion;
import be.uclouvain.solvercheck.generators.GenBuilder;

import java.util.Arrays;
import java.util.Iterator;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * This class implements an "higher order" assertion which checks that the
 * parametric assertion holds for all values generated by the given generator.
 */
public final class ForAllAssertion {
    /** An utility class has no public constructor. */
    private ForAllAssertion() { }

    /**
     * Creates a 1-parametric assertion.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param genA the generator creating the generated 1-parameter
     * @param <A> the type of the parameter produced by the generator
     * @return a hook to conveniently express a 1-parametric assertion.
     */
    public static <A> Forall1<A> forAll(final GenBuilder<A> genA) {
        return new Forall1<>(genA);
    }

    /**
     * Creates a 2-parametric assertion.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param genA the generator creating the generated 1st argument.
     * @param genB the generator creating the generated 2nd argument.
     * @param <A> the type of the parameter produced by the 1st generator
     * @param <B> the type of the parameter produced by the 2nd generator
     * @return a hook to conveniently express a 2-parametric assertion.
     */
    public static <A, B> Forall2<A, B> forAll(
            final GenBuilder<A> genA,
            final GenBuilder<B> genB) {

        return new Forall2<>(genA, genB);
    }

    /**
     * This class provides a hook to create and customize 1-parametric
     * assertions. The set of classes Forall{1..4} pretty much reflects
     * `QuickTheories` set of `TheoryBuilder{1..4}` classes.
     *
     * @param <A> the type of the generated parameter
     */
    public static final class Forall1<A> {
        /** The generator creating the generated 1st argument. */
        private final GenBuilder<A> genA;
        /**
         * A predicate encapsulating the assumptions used to filter out
         * parameter values which are not relevant for the test at hand.
         */
        private Predicate<A> assumptions;

        /**
         * The number of inputs that will be auto generated
         */
        private int examples;

        /**
         * Creates a new hook to facilitate the writing of 1-parametric
         * assertions.
         *
         * @param genA the generator creating the generated 1st argument.
         */
        public Forall1(final GenBuilder<A> genA) {
            this.genA = genA;
            this.examples = 10;
            this.assumptions = a -> true;
        }

        /**
         * Constrains the values allowed for the generated parameters.
         *
         * @param assumption a predicate that must be true of all values
         * @return this
         */
        public Forall1<A> assuming(final Predicate<A> assumption) {
            this.assumptions = this.assumptions.and(assumption);
            return this;
        }

        /**
         * Constrains the number of generated tests (could also be set via a
         * call to limit on the stream).
         *
         * @param n the number of examples to generate
         * @return this
         */
        public Forall1<A> withExamples(final int n) {
            this.examples = n;
            return this;
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameter.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsTrueThat(final Predicate<A> assertion) {
            return assertThat(a -> rnd -> {
                    if (!assertion.test(a)) {
                        throw new AssertionError(
                           "\nCAUSE     : Property violated"
                        );
                    }
                }
            );
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameter.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsFalseThat(final Predicate<A> assertion) {
            return itIsTrueThat(assertion.negate());
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameter.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion assertThat(final Function<A, Assertion> assertion) {
            return randomness -> {
                genA.build()
                   .generate(randomness)
                   .limit(examples)
                   .filter(assumptions)
                   //.parallel()
                   .forEach(a -> {
                       try {
                           assertion.apply(a).check(randomness);
                       } catch (AssertionError cause) {
                            throw new AssertionError(
                               explanation(a, cause.getMessage()),
                               cause);
                       } catch (Throwable cause) {
                           throw new AssertionError(
                              explanation(a,
                              "\nCAUSE     : An exception was caught"
                                 + "\n###########################"),
                              cause);
                       }
                   });
            };
        }

        private String explanation(final A a, final String cause) {
            final StringBuilder builder = new StringBuilder("\n");
            builder.append("########################### \n");
            builder.append(genA.name()).append(" : ").append(describe(a));
            builder.append(cause);
            return builder.toString();
        }
    }

    /**
     * This class provides a hook to create and customize 2-parametric
     * assertions. The set of classes Forall{1..4} pretty much reflects
     * `QuickTheories` set of `TheoryBuilder{1..4}` classes.
     *
     * @param <A> the type of the 1st generated parameter
     * @param <B> the type of the 2nd generated parameter
     */
    public static final class Forall2<A, B> {
        /** The generator creating the generated 1st argument. */
        private final GenBuilder<A> genA;
        /** The generator creating the generated 2nd argument. */
        private final GenBuilder<B> genB;
        /**
         * The number of inputs that will be auto generated
         */
        private int examples;
        /**
         * A predicate encapsulating the assumptions used to filter out
         * parameter values which are not relevant for the test at hand.
         */
        private BiPredicate<A, B> assumptions;

        /**
         * Creates a new hook to facilitate the writing of 2-parametric
         * assertions.
         *
         * @param genA the generator creating the generated 1st argument.
         * @param genB the generator creating the generated 2nd argument.
         */
        public Forall2(
                final GenBuilder<A> genA,
                final GenBuilder<B> genB) {

            this.genA = genA;
            this.genB = genB;
            this.examples = 10;
            this.assumptions = (a, b) -> true;
        }

        /**
         * Constrains the values allowed for the generated parameters.
         *
         * @param assumption a predicate that must be true of all values
         * @return this
         */
        public Forall2<A, B> assuming(final BiPredicate<A, B> assumption) {
            this.assumptions = this.assumptions.and(assumption);
            return this;
        }

        /**
         * Constrains the number of generated tests (could also be set via a
         * call to limit on the stream).
         *
         * @param n the number of examples to generate
         * @return this
         */
        public Forall2<A, B> withExamples(final int n) {
            this.examples = n;
            return this;
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameter.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsTrueThat(final BiPredicate<A, B> assertion) {
            return assertThat((a, b) -> rnd -> {
                   if (!assertion.test(a, b)) {
                       throw new AssertionError(
                          "\nCAUSE     : Property violated"
                       );
                   }
               }
            );
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameter.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsFalseThat(final BiPredicate<A, B> assertion) {
            return itIsTrueThat(assertion.negate());
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameters.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion assertThat(final BiFunction<A, B, Assertion> assertion) {
            return randomness -> {
                Iterator<A> iterA = genA.build().generate(randomness).iterator();
                Iterator<B> iterB = genB.build().generate(randomness).iterator();

                int counter = 0;
                while (counter < examples) {
                    A itemA = iterA.next();
                    B itemB = iterB.next();

                    try {
                        if (!assumptions.test(itemA, itemB)) {
                            continue;
                        } else {
                            counter++;
                        }

                        assertion.apply(itemA, itemB).check(randomness);
                    } catch (AssertionError cause) {
                      throw new AssertionError(
                         explanation(itemA, itemB, cause.getMessage()),
                         cause);
                    } catch (Throwable cause) {
                      throw new AssertionError(
                         explanation(itemA, itemB,
                    "\nCAUSE     : An exception was caught"
                       + "\n###########################"),
                         cause);
                    }
                }
            };
        }

        private String explanation(final A a, final B b, final String cause) {
            final StringBuilder builder = new StringBuilder("\n");
            builder.append("########################### \n");
            builder.append(genA.name()).append(" : ").append(describe(a)).append("\n");
            builder.append(genB.name()).append(" : ").append(describe(b));
            builder.append(cause);
            return builder.toString();
        }
    }

    private static final <T> String describe(final T t) {
        Class<T> clazz = (Class<T>) t.getClass();
        if (clazz.isArray()) {
            if (clazz.getComponentType().isPrimitive()) {
                if (int[].class.equals(clazz)) {
                    return Arrays.toString((int[]) t);
                } else if (long[].class.equals(clazz)) {
                    return Arrays.toString((long[]) t);
                } else if (short[].class.equals(clazz)) {
                    return Arrays.toString((short[]) t);
                } else if (byte[].class.equals(clazz)) {
                    return Arrays.toString((byte[]) t);
                } else if (char[].class.equals(clazz)) {
                    return Arrays.toString((char[]) t);
                } else if (double[].class.equals(clazz)) {
                    return Arrays.toString((double[]) t);
                } else if (float[].class.equals(clazz)) {
                    return Arrays.toString((float[]) t);
                } else if (boolean[].class.equals(clazz)) {
                    return Arrays.toString((boolean[]) t);
                }
                return "Unknown type ! (This should never happen)";
            } else {
                return Arrays.toString((Object[]) t);
            }
        } else {
            return t.toString();
        }
    }
}
