package be.uclouvain.solvercheck.assertions.util;

import be.uclouvain.solvercheck.assertions.Assertion;

import java.util.Iterator;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;

/**
 * This class implements an "higher order" assertion which checks that the
 * parametric assertion holds for all values generated by the given generator.
 */
public final class ForAllAssertion {
    /** An utility class has no public constructor. */
    private ForAllAssertion() { }

    /**
     * Creates a 1-parametric assertion.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param genA the generator creating the generated 1-parameter
     * @param <A> the type of the parameter produced by the generator
     * @return a hook to conveniently express a 1-parametric assertion.
     */
    public static <A> Forall1<A> forAll(final Stream<A> genA) {
        return new Forall1<>(genA);
    }

    /**
     * Creates a 2-parametric assertion.
     *
     * This is particularly useful to check that not only constraint behave
     * correctly no matter what partial assignment they are facing, but also
     * to show that they behave correctly no matter the way they are configured.
     *
     * @param genA the generator creating the generated 1st argument.
     * @param genB the generator creating the generated 2nd argument.
     * @param <A> the type of the parameter produced by the 1st generator
     * @param <B> the type of the parameter produced by the 2nd generator
     * @return a hook to conveniently express a 2-parametric assertion.
     */
    public static <A, B> Forall2<A, B> forAll(
            final Stream<A> genA,
            final Stream<B> genB) {

        return new Forall2<>(genA, genB);
    }

    /**
     * This class provides a hook to create and customize 1-parametric
     * assertions. The set of classes Forall{1..4} pretty much reflects
     * `QuickTheories` set of `TheoryBuilder{1..4}` classes.
     *
     * @param <A> the type of the generated parameter
     */
    public static final class Forall1<A> {
        /** The generator creating the generated 1st argument. */
        private final Stream<A> genA;
        /**
         * A predicate encapsulating the assumptions used to filter out
         * parameter values which are not relevant for the test at hand.
         */
        private Predicate<A> assumptions;

        /**
         * The number of inputs that will be auto generated
         */
        private int examples;

        /**
         * Creates a new hook to facilitate the writing of 1-parametric
         * assertions.
         *
         * @param genA the generator creating the generated 1st argument.
         */
        public Forall1(final Stream<A> genA) {
            this.genA = genA;
            this.examples = 10;
            this.assumptions = a -> true;
        }

        /**
         * Constrains the values allowed for the generated parameters.
         *
         * @param assumption a predicate that must be true of all values
         * @return this
         */
        public Forall1<A> assuming(final Predicate<A> assumption) {
            this.assumptions = this.assumptions.and(assumption);
            return this;
        }

        /**
         * Constrains the number of generated tests (could also be set via a
         * call to limit on the stream).
         *
         * @param n the number of examples to generate
         * @return this
         */
        public Forall1<A> withExamples(final int n) {
            this.examples = n;
            return this;
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameter.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsTrueThat(final Function<A, Assertion> assertion) {
            return () -> {
                genA
                   .limit(examples)
                   .filter(assumptions)
                   .parallel()
                   .forEach(a -> {
                       try {
                           assertion.apply(a).check();
                       } catch (AssertionError cause) {
                            throw new AssertionError(
                               explanation(a, cause.getMessage()),
                               cause);
                       } catch (Throwable cause) {
                           throw new AssertionError(
                              explanation(a,
                              "\nCAUSE     : An exception was caught"
                                 + "\n###########################"),
                              cause);
                       }
                   });
            };
        }

        private String explanation(final A a, final String cause) {
            final StringBuilder builder = new StringBuilder("\n");
            builder.append("########################### \n");
            builder.append("CONTEXT A : ").append(a);
            builder.append(cause);
            return builder.toString();
        }
    }

    /**
     * This class provides a hook to create and customize 2-parametric
     * assertions. The set of classes Forall{1..4} pretty much reflects
     * `QuickTheories` set of `TheoryBuilder{1..4}` classes.
     *
     * @param <A> the type of the 1st generated parameter
     * @param <B> the type of the 2nd generated parameter
     */
    public static final class Forall2<A, B> {
        /** The generator creating the generated 1st argument. */
        private final Stream<A> genA;
        /** The generator creating the generated 2nd argument. */
        private final Stream<B> genB;
        /**
         * The number of inputs that will be auto generated
         */
        private int examples;
        /**
         * A predicate encapsulating the assumptions used to filter out
         * parameter values which are not relevant for the test at hand.
         */
        private BiPredicate<A, B> assumptions;

        /**
         * Creates a new hook to facilitate the writing of 2-parametric
         * assertions.
         *
         * @param genA the generator creating the generated 1st argument.
         * @param genB the generator creating the generated 2nd argument.
         */
        public Forall2(
                final Stream<A> genA,
                final Stream<B> genB) {

            this.genA = genA;
            this.genB = genB;
            this.examples = 10;
            this.assumptions = (a, b) -> true;
        }

        /**
         * Constrains the values allowed for the generated parameters.
         *
         * @param assumption a predicate that must be true of all values
         * @return this
         */
        public Forall2<A, B> assuming(final BiPredicate<A, B> assumption) {
            this.assumptions = this.assumptions.and(assumption);
            return this;
        }

        /**
         * Constrains the number of generated tests (could also be set via a
         * call to limit on the stream).
         *
         * @param n the number of examples to generate
         * @return this
         */
        public Forall2<A, B> withExamples(final int n) {
            this.examples = n;
            return this;
        }

        /**
         * Lets you express the parametric assertion in terms of its actual
         * parameters.
         *
         * @param assertion the parametric assertion expressed in terms of
         *                  its abstract parameters.
         * @return the (parametric) assertion which can be checked.
         */
        public Assertion itIsTrueThat(final BiFunction<A, B, Assertion> assertion) {
            return () -> {
                Iterator<A> iterA = genA.iterator();
                Iterator<B> iterB = genB.iterator();

                int counter = 0;
                while (counter < examples) {
                    A itemA = iterA.next();
                    B itemB = iterB.next();

                    try {
                        if (!assumptions.test(itemA, itemB)) {
                            continue;
                        } else {
                            counter++;
                        }

                        assertion.apply(itemA, itemB).check();
                    } catch (AssertionError cause) {
                      throw new AssertionError(
                         explanation(itemA, itemB, cause.getMessage()),
                         cause);
                    } catch (Throwable cause) {
                      throw new AssertionError(
                         explanation(itemA, itemB,
                    "\nCAUSE     : An exception was caught"
                       + "\n###########################"),
                         cause);
                    }
                }
            };
        }

        private String explanation(final A a, final B b, final String cause) {
            final StringBuilder builder = new StringBuilder("\n");
            builder.append("########################### \n");
            builder.append("CONTEXT A : ").append(a).append("\n");
            builder.append("CONTEXT B : ").append(b);
            builder.append(cause);
            return builder.toString();
        }
    }
}
