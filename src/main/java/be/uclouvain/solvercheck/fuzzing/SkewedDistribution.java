package be.uclouvain.solvercheck.fuzzing;

import java.util.Random;
import java.util.stream.IntStream;

/**
 * This class implements a skewed integer distribution using a mixture model.
 * It facilitates the generation of pseudo random integer which we distribute
 * according to a precisely described probability distribution.
 *
 * This distribution is typically *multimodal* and composed according to the
 * usual mixture model. The modes of the distribution are easily specified
 * and their likelihood can be specified too.
 */
public final class SkewedDistribution {
    /** The lowest value that may possibly be generated. */
    private final int low;
    /** The highest value that may possibly be generated. */
    private final int high;
    /** The width of the peaks. */
    private final double spread;
    /** The value at the center of the 'peaks'. */
    private final int[]  modes;
    /**
     * The mixture coefficient of the modes.
     *
     * If each item in `mode` is considered as a separate variable, the
     * mixture coeffficient `i` indicates the likelihood that this distribution
     * behaves as a normal distribution for variable `mode[i]`.
     *
     * Note:
     *   In case the sum of the mixture coefficients does not amount to 1,
     *   then the distribution behaves as an *uniform distribution* with
     *   probability 1-sum(mixtureCoefficients).
     *
     * Warning:
     *   The sum of the mixture coefficients may obviously
     *   *NEVER BE GREATER THAN ONE* .
     */
    private final double[] mixtureCoefficients;

    /**
     * Memo of the cumulated sum of mixture coefficients. This is useful to
     * speedup the 'flip a coin' phase of the generation algorithm.
     */
    private final double[] cumsum;

    /**
     * Fully configurable skewed distribution constructor.
     *
     * @param low    the lowest value that can possibly be generated.
     * @param high   the highest value that can possibly be generated.
     * @param spread the maximum spread between the lowest and highest values
     *               that are actually generated.
     * @param modes  the peaks of the distribution.
     * @param mixtureCoefficients the probability mass concentrated in the
     */
    public SkewedDistribution(
       final int      low,
       final int      high,
       final int      spread,
       final int[]    modes,
       final double[] mixtureCoefficients
    ) {
        if (modes.length != mixtureCoefficients.length) {
            throw new IllegalArgumentException(
               "The modes and mixture coefficients must be the same size");
        }

        this.low                 = low;
        this.high                = high;
        this.spread              = spread / 2.0;
        this.modes               = modes;
        this.mixtureCoefficients = mixtureCoefficients;
        this.cumsum              = new double[modes.length];

        initializeCumSum();
    }

    /**
     * Generates the next integer distributed somewhere along this distribution.
     *
     * @param prng an initialized source of randomness
     * @return a pseudo random number drawn from the current distribution.
     */
    public int next(final Random prng) {
        double coin = prng.nextDouble();
        int     cmp = component(coin);

        return next(prng, cmp);
    }

    /**
     * Returns a stream of ints drawn from anywhere in the distribution.
     *
     * @param prng the source of randomness.
     * @return a stream of ints drawn from anywhere in the distribution.
     */
    public IntStream ints(final Random prng) {
        return IntStream.generate(() -> next(prng));
    }

    /**
     * Returns a stream of ints all drawn from one same component of
     * the distribution.
     *
     * @param prng the source of randomness.
     * @return a stream of ints all drawn from one same component of the
     * distribution (possibly from the uniform component).
     */
    public IntStream colocatedInts(final Random prng) {
            final double coin = prng.nextDouble();
            final int     cmp = component(coin);

            return IntStream.generate(() -> next(prng, cmp));
    }

    /**
     * Returns a stream of ints drawn from anywhere in the distribution
     * ++enforcing a strict application of the spread++. That is, the distance
     * between any two values generated by this stream will be at most `spread`.
     *
     * @param prng the source of randomness.
     * @return a stream of ints drawn from anywhere in the distribution.
     */
    public IntStream strictSpreadInts(final Random prng) {
        final long anchor = next(prng);

        return ints(prng).filter(i -> i >= anchor - spread && i <= anchor + spread);
    }

    /**
     * Returns a stream of ints all drawn from one same component of
     * the distribution, ++enforcing a strict application of the spread++.
     * That is, the distance between any two values generated by this stream
     * will be at most `spread`.
     *
     * @param prng the source of randomness.
     * @return a stream of ints drawn from anywhere in the distribution.
     */
    public IntStream strictSpreadColocatedInts(final Random prng) {
        final double coin = prng.nextDouble();
        final int     cmp = component(coin);
        final long anchor = next(prng, cmp);

        return IntStream.generate(() -> next(prng, cmp))
                        .filter(i -> i >= anchor - spread && i <= anchor + spread);
    }

    /**
     * Returns the next integer drawn pseudo randomly from the `cmp`th
     * component of the distribution. (-1 means uniform)
     *
     * @param prng the source of randomness.
     * @param cmp  the component id (-1 for uniform distribution)
     * @return a value picked from the `cmp`th distribution.
     */
    @SuppressWarnings("checkstyle:magicnumber")
    private int next(final Random prng, final int cmp) {
        if (cmp >= 0) {
            return (int) Math.round(prng.nextGaussian() * spread / 4 + modes[cmp]);
        } else { // it is the "uniform distribution case".
            return prng.nextInt((high - low) + 1) + low;
        }
    }

    /**
     * Computes the cum sum once for all.
     */
    private void initializeCumSum() {
        if (modes.length < 1) {
            return;
        }

        cumsum[0] = mixtureCoefficients[0];
        for (int i = 1; i < cumsum.length; i++) {
            cumsum[i] = cumsum[i - 1] + mixtureCoefficients[i];
        }

        if (cumsum[cumsum.length - 1] > 1) {
            throw new IllegalArgumentException(
               "The cumulated sum of the mixture coefficients may not be > 1");
        }
    }

    /**
     * Identifies the 'component' (mode or uniform distrib) of the distribution
     * which should drive the occurrence of the next value.
     *
     * @param coin a 'coin' which has been flipped to tell the component to use.
     * @return the identifier of a component ([0; cumsum.length-1])
     *         or -1 if the next value should be generated according to an
     *         uniform distribution.
     */
    private int component(final double coin) {
        // There should only be a small number of modes (2-3) so O(n) does not
        // hurt and the constant factor plays in our favor
        for (int i = 0; i < cumsum.length; i++) {
            if (coin < cumsum[i]) {
                return i;
            }
        }
        return -1;
    }

    /*-
     * Test driver that produces a csv for me to validate the correct behavior
     * of the distribution.
     *
     *  public static void main(String[] args) {
     *      int    []   cnt = new int[100];
     *      int      spread = 10;
     *      int    [] modes = {20, 50, 80};
     *      double [] coeff = {.3, .2, .1};
     *
     *
     *      SkewedDistribution dist
     *         = new SkewedDistribution(10, 90 , spread, modes, coeff);
     *
     *      Random prng = new Random();
     *
     *      dist.strictSpreadInts(prng).limit(10000).forEach(i -> cnt[i]++);
     *
     *      for (int i = 0; i < cnt.length; i++) {
     *          System.err.format("%d ; %d %n", i, cnt[i]);
     *      }
     *  }
     *
     */
}
